package main

/**
go 的 map底层使用哈希作为底层实现， 哈希桶

哈希冲突： 当两个或以上的key被哈希到同一个bucket时，我们称之为键发生了冲突
go怎么解决哈希冲突？
		Go使用链地址法来解决键冲突  ， 超出bucket后，就再创建一个键值对，用类似链表的方式将bucket链接起来 ，多个桶链接到一起

负载因子： 键数量 / bucket数量     衡量一个哈希表冲突情况
负载因子应该控制在合适大小，超过阈值就rehash
  - 负载因子过小，说明资源利用率低
  - 负载因子过大，说明冲突严重，存取效率低

每个哈希表实现对负载因子容忍度不同，redis实现中超过1就触发rehash， 而go实现中则在负载因子达到6.5时才会rehash

扩容：
  - 触发条件： 负载因子 > 6.5 ; overflow 数量超过 2^15
  - 增量扩容， oldbucket 每次访问 就搬迁两个过去 ，搬迁完后删除oldbucket
  - 等量扩容，并不是扩大容量，只是搬迁一遍 重新排列key以节省空间，提升访问效率， 如：不断增删 导致 overflow bucket数量增多，但负载因子并不高，无法搬迁的场景

查找过程：
 1.根据key 计算哈希值
 2.取哈希值低位，与B取模，确定bucket位置
 3.取哈希值高位，tophash数组中查询
 4.如果tophash[i] 中存储值也与哈希值高位相等，则去找该bucket中的key值进行比较
 5.当前bucket中没有找到，则继续从下一个overflow bucket中查找
 6.如果当前处于搬迁过程，则优先从oldbuckets查找

注意：如果找不到不会返回空值！而是返回对应类型的零值
*/
