package main

import (
	"fmt"
	"math"
)

/**
内存管理：
arena（堆内存）  ------>    bitmap   ------------>  spans       -------------------> span  ------------> page
                                                                       内存管理基本单位，包含1页或多页
512G                        16G                    512M
                                                  存放span的指针

                           主要用于GC
page 8k, 页是为了方便管理规划内存

512G/8k 个 page


根据对象大小又划分了一系列class，每个class都代表一个固定大小的对象，以及每个span的大小
*/

/**
垃圾回收：
业界常见的垃圾回收算法：
1.引用计数
	- 回收快，但是有一定性能损耗，也不能解决循环引用的问题
    - 代表语言：python、PHP、swift
2.标记-清除
    - 解决了引用计数的痛点，但是需要STW（stop the world），即需要暂时停掉程序运行， 在go中就是停掉所有的goroutine，专心做垃圾回收
    - 代表语言：golang （三色标记法） 白色--》灰色--》黑色
3.分代收集
    - 回收性能好，算法复杂。生命周期长的放入老年代，而短的放入新生代，不同代有
    - 代表语言：java
*/

/**
垃圾回收优化：
golang中所谓的垃圾回收优化，就是要尽可能的缩短STW， 具体采取了如下手段：
1.写屏障技术：让gc和goroutine可以同时运行，大大缩短STW，而不是消除STW
2.辅助GC技术：goroutine如果在gc期间需要分配内存，那么它会参与一部分gc工作
*/

/**
垃圾回收触发机制：
1.达到阈值触发  ： 内存增长一倍
2.定期GC   ：  2min
3.手动触发 ： runtime.GC()
*/

/**
逃逸分析： 指内存分配的位置由编译器决定，而不是程序员
   - 分配在栈中，则函数执行完自动回收
   - 分配在堆中，则函数 执行结束交给GC处理

由于指针传递会产生逃逸，可能会使用堆，从而增加GC负担，所以传递指针并不一定是高效的
*/

func main() {
	pages := math.Ceil(float64(2264 / 30))
	pages1 := math.Floor(2264 / 30)

	fmt.Println(pages, pages1)
}
